
<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <!--[if lte IE 8]>
      <script type="text/javascript">
        var tags = ['header', 'footer', 'nav', 'aside', 'article', 'section', 'object', 'main'];
        for (var i in tags) {
          document.createElement(tags[i]);
        }
      </script>
    <![endif]-->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>84 Largest Rectangle in Histogram</title>
    <!-- font -->
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" />
    <!-- js -->
    <script type="text/javascript" src="/js/jquery-3.3.1.min.js"></script>
    <!-- css -->
    <link rel="stylesheet" href="/css/reset.css" />
    <link rel="stylesheet" href="/css/icon.css" />
    <link rel="stylesheet" href="/katex/katex.min.css" />
     
    <link rel="stylesheet" href="/css/index.css" />
     
  <meta name="generator" content="Hexo 5.4.1"></head>

  <body>
    <!-- header -->
    <header class="header">
  <div class="logo">
    <!-- logo -->
    <div class="logo-wrap">
      <a href="/" id="logo"></a>
    </div>
  </div>
  <nav class="nav" id="top-nav">
    <ul>
      
        <li>
          <a class="" href="/">主页</a>
        </li>
      
        <li>
          <a class="" href="/categories">分类</a>
        </li>
      
        <li>
          <a class="" href="/tags">标签</a>
        </li>
      
        <li>
          <a class="" href="/archives">归档</a>
        </li>
      
      <!-- search -->
      
    </ul>
  </nav>
</header>


  
    <!-- main -->
    <main id="main" class="main">
      <!-- post -->

<div class="post show-toc">
  <!-- table of content -->
  
    <div class="post-toc">
      <div class="post-toc-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text"> 题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text"> 解题思路</span></a></li></ol>
      </div>
    </div>
  
  <!-- table of content end-->
  <!-- article -->
  <div class="cell">
    <article class="article">
      <!-- title -->
      
          <h1  class="title">84 Largest Rectangle in Histogram</h1> 
      
      <div class="post-meta">
        <!-- time -->
        
          <span class="icon-baseline-query_builder-24px"></span>
          <time datetime="2020-05-18T16:00:00.000Z">
            2020-05-19
          </time>
        
        <!-- categories -->
        <!--
          <span class="icon-baseline-work_outline-24px"></span>
          
            <a href="/categories/leetcode/">
              <span>leetcode</span>
            </a>
          
        -->
        <!-- categories end -->
        <!-- tag -->
        <span class="icon-baseline-subtitles-24px"></span>
        
          <a href="/tags/leetcode/">
            <span>leetcode</span>
          </a>
        
      </div>
      <!-- content -->
      <div class="article-content">
      <h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<span id="more"></span>
<p><img src="/img/5640e8ee.png" alt="5640e8ee.png" /></p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="/img/414f79ca.png" alt="414f79ca.png" /></p>
<p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>Example:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>
<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2>
<p>求解可表示的最大矩形面积,需要知道每个整数(heights[i])可表示的最大面积.<br />
可以依次遍历 heights 中元素, 找出 heights[i] 左右两侧第一个比 heights[i] 小的元素.即可算出 heights[i] 的最大可覆盖面积.<br />
以 [1, 3, 4, 5, 2, 6, 1] 中的 2 为例.<br />
在 2 的左右两侧, 比 2 小的整数的下标为 0 和 6.则 2 的最大可覆盖面积为:</p>
<p>(right - left - 1) * height = (6 - 0 - 1) * 2= 8</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 (下标)</span><br><span class="line">-------------</span><br><span class="line">1 3 4 5 2 6 1</span><br><span class="line"></span><br><span class="line">left  = 0</span><br><span class="line">right = 6</span><br></pre></td></tr></table></figure>
<p>如果在遍历 heights 时, 每次都向两侧查找 heights[i] 的边界,则其时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.<br />
(遍历一遍 heights 为 n, 每个 heights[i] 还需要分别往左右两侧各跑一次合计为 n.)</p>
<p>可以利用单调栈的性质,快速定位 heights[i] 的左右边界,将其时间复杂度降为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>.<br />
(只需要跑一趟)</p>
<p>单调栈可以分为单调递增栈和单调递减栈两种,其栈内元素从栈尾到栈顶依次递增(单调递增栈, 栈顶元素最大,栈尾元素最小)/依次递减(单调递减栈, 栈顶元素最小, 栈尾元素最大).</p>
<p>创建一个单调递增栈 stack = [-1] 来储存 heights[i] 的下标 i. 其中的 -1 作为守卫,代表 heights[0] 的 left, 避免操作数组时越界.</p>
<p>以 [3, 3, 4, 5, 2, 6, 1] 中的 2 为例.<br />
在 2 的左侧, 没有比 2 小的元素,因此去 -1 作为 左侧的边界.2 的最大可覆盖面积为:</p>
<p>(6 - (-1) - 1) * 2 = 12</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1 0 1 2 3 4 5 6 (下标)</span><br><span class="line">-----------------</span><br><span class="line">   3 3 4 5 2 6 1</span><br><span class="line"></span><br><span class="line">left  = -1</span><br><span class="line">right = 6</span><br></pre></td></tr></table></figure>
<p>然后依次遍历 heights 中元素.<br />
如果 heights[i] 大于/等于 heights[stack[top]],则将 heights[i] 推入栈中.<br />
如果 height[i] 小于 heights[stack[top]],则先计算 heights[stack[top]] 可表示的最大面积,因为:</p>
<ul>
<li>i 一定是 stack[top] 的 right(右边界, stack[top] 右侧的第一个比 stack[top] 小的值).</li>
<li>stack[top - 1] 一定是 stack[top] 的 left(左边界, 比 heights[stack[top]] 大的都被弹出去了).</li>
</ul>
<p>以 [2, 3, 1] 中的 3 为例:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 (下标)</span><br><span class="line">-----</span><br><span class="line">2 3 1</span><br><span class="line"></span><br><span class="line">left  = 0</span><br><span class="line">right = 2</span><br></pre></td></tr></table></figure>
<p>当遍历到 1 时, stack = [1, 0, -1]<br />
因为 2 3 比 1 大, 所以 1 一定是 2 3 的 right(右边界).<br />
此时 3 左边界为 heights[stack[top - 1]] = 0, 其最大面积为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span> - <span class="number">0</span> - <span class="number">1</span>) * <span class="number">3</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>然后将 heights[stack[top]] 从栈中弹出,将 height[i] 推入栈中.<br />
遍历结束后, 如果 stack.length &gt; 1 (栈里还有除守卫(-1)外的其他下标),则此时的 right 一定是 heights.length.</p>
<p>例如 [1, 2, 3]. 因为其本身就是递增关系, 所以不会触发出栈操作.当 heights 遍历结束时, 其 stack 为:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>此时 heights 元素 1, 2, 3 的 left (左边界) 下标分别为 -1, 0, 1, right (右边界) 为最后一个元素的右侧.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 (下标)</span><br><span class="line">----------------</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">right = 3</span><br></pre></td></tr></table></figure>
<p>使用 JavaScript 的数组模拟栈的操作:</p>
<ul>
<li>stack[0] 为获取栈顶元素</li>
<li>stack[1] 为栈顶的下一个元素</li>
<li>stack[stack.length - 1] 为获取栈底元素</li>
<li>stack.unshift() 入栈</li>
<li>stack.shift() 出栈(获取值并将其从栈顶删除)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">largestRectangleArea</span>(<span class="params">heights</span>) &#123;</span><br><span class="line">  <span class="comment">// 用数组模拟栈</span></span><br><span class="line">  <span class="keyword">const</span> stack = [-<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 因为 heights[i] &lt; heights[stack[0]], 所以 i 一定是 stack[0] (栈顶元素)的右边界.</span></span><br><span class="line">    <span class="keyword">while</span> (stack[<span class="number">0</span>] &gt; -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[stack[<span class="number">0</span>]]) &#123;</span><br><span class="line">      <span class="keyword">const</span> height = heights[stack[<span class="number">0</span>]];</span><br><span class="line">      <span class="comment">// 计算栈顶元素的最大可面积, 与之前的最大面积比较</span></span><br><span class="line">      maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, height * (i - stack[<span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">      <span class="comment">// 出栈</span></span><br><span class="line">      stack.<span class="title function_">shift</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    stack.<span class="title function_">unshift</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 栈中除了 -1 外还有别的下标</span></span><br><span class="line">  <span class="keyword">while</span> (stack[<span class="number">0</span>] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> height = heights[stack[<span class="number">0</span>]];</span><br><span class="line">    <span class="comment">// 判断剩余元素可表示的最大面积</span></span><br><span class="line">    maxArea = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxArea, height * (heights.<span class="property">length</span> - stack[<span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">    stack.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      </div>
    </article>
  </div>
  <!-- pagination -->
  
    <nav class="pagination">
      
        <a class="prev" href="/article/TCP%20%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%BB%88%E6%AD%A2%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B/">&lt;  TCP 建立连接与终止连接的过程</a>
      
      
        <a class="next" href="/article/121%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/">121 Best Time to Buy and Sell Stock  &gt;</a>
      
    </nav>    
  
  <!-- pagination end -->
</div>






    </main>

    <!-- search -->
     
    
    <script src="/js/main.js"></script>
     
  </body>
</html>
